// Code generated by counterfeiter. DO NOT EDIT.
package list_operator_fakes

import (
	"sync"

	list_operator_mocks "gitlab.com/pietroski-software-company/lightning-db/pkg/tools/list-operator/mocks"
)

type FakeCallers struct {
	ActionFunc1Stub        func() error
	actionFunc1Mutex       sync.RWMutex
	actionFunc1ArgsForCall []struct {
	}
	actionFunc1Returns struct {
		result1 error
	}
	actionFunc1ReturnsOnCall map[int]struct {
		result1 error
	}
	ActionFunc2Stub        func() error
	actionFunc2Mutex       sync.RWMutex
	actionFunc2ArgsForCall []struct {
	}
	actionFunc2Returns struct {
		result1 error
	}
	actionFunc2ReturnsOnCall map[int]struct {
		result1 error
	}
	ActionFunc3Stub        func() error
	actionFunc3Mutex       sync.RWMutex
	actionFunc3ArgsForCall []struct {
	}
	actionFunc3Returns struct {
		result1 error
	}
	actionFunc3ReturnsOnCall map[int]struct {
		result1 error
	}
	RollbackActionFunc1Stub        func() error
	rollbackActionFunc1Mutex       sync.RWMutex
	rollbackActionFunc1ArgsForCall []struct {
	}
	rollbackActionFunc1Returns struct {
		result1 error
	}
	rollbackActionFunc1ReturnsOnCall map[int]struct {
		result1 error
	}
	RollbackActionFunc2Stub        func() error
	rollbackActionFunc2Mutex       sync.RWMutex
	rollbackActionFunc2ArgsForCall []struct {
	}
	rollbackActionFunc2Returns struct {
		result1 error
	}
	rollbackActionFunc2ReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCallers) ActionFunc1() error {
	fake.actionFunc1Mutex.Lock()
	ret, specificReturn := fake.actionFunc1ReturnsOnCall[len(fake.actionFunc1ArgsForCall)]
	fake.actionFunc1ArgsForCall = append(fake.actionFunc1ArgsForCall, struct {
	}{})
	stub := fake.ActionFunc1Stub
	fakeReturns := fake.actionFunc1Returns
	fake.recordInvocation("ActionFunc1", []interface{}{})
	fake.actionFunc1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCallers) ActionFunc1CallCount() int {
	fake.actionFunc1Mutex.RLock()
	defer fake.actionFunc1Mutex.RUnlock()
	return len(fake.actionFunc1ArgsForCall)
}

func (fake *FakeCallers) ActionFunc1Calls(stub func() error) {
	fake.actionFunc1Mutex.Lock()
	defer fake.actionFunc1Mutex.Unlock()
	fake.ActionFunc1Stub = stub
}

func (fake *FakeCallers) ActionFunc1Returns(result1 error) {
	fake.actionFunc1Mutex.Lock()
	defer fake.actionFunc1Mutex.Unlock()
	fake.ActionFunc1Stub = nil
	fake.actionFunc1Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCallers) ActionFunc1ReturnsOnCall(i int, result1 error) {
	fake.actionFunc1Mutex.Lock()
	defer fake.actionFunc1Mutex.Unlock()
	fake.ActionFunc1Stub = nil
	if fake.actionFunc1ReturnsOnCall == nil {
		fake.actionFunc1ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.actionFunc1ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCallers) ActionFunc2() error {
	fake.actionFunc2Mutex.Lock()
	ret, specificReturn := fake.actionFunc2ReturnsOnCall[len(fake.actionFunc2ArgsForCall)]
	fake.actionFunc2ArgsForCall = append(fake.actionFunc2ArgsForCall, struct {
	}{})
	stub := fake.ActionFunc2Stub
	fakeReturns := fake.actionFunc2Returns
	fake.recordInvocation("ActionFunc2", []interface{}{})
	fake.actionFunc2Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCallers) ActionFunc2CallCount() int {
	fake.actionFunc2Mutex.RLock()
	defer fake.actionFunc2Mutex.RUnlock()
	return len(fake.actionFunc2ArgsForCall)
}

func (fake *FakeCallers) ActionFunc2Calls(stub func() error) {
	fake.actionFunc2Mutex.Lock()
	defer fake.actionFunc2Mutex.Unlock()
	fake.ActionFunc2Stub = stub
}

func (fake *FakeCallers) ActionFunc2Returns(result1 error) {
	fake.actionFunc2Mutex.Lock()
	defer fake.actionFunc2Mutex.Unlock()
	fake.ActionFunc2Stub = nil
	fake.actionFunc2Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCallers) ActionFunc2ReturnsOnCall(i int, result1 error) {
	fake.actionFunc2Mutex.Lock()
	defer fake.actionFunc2Mutex.Unlock()
	fake.ActionFunc2Stub = nil
	if fake.actionFunc2ReturnsOnCall == nil {
		fake.actionFunc2ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.actionFunc2ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCallers) ActionFunc3() error {
	fake.actionFunc3Mutex.Lock()
	ret, specificReturn := fake.actionFunc3ReturnsOnCall[len(fake.actionFunc3ArgsForCall)]
	fake.actionFunc3ArgsForCall = append(fake.actionFunc3ArgsForCall, struct {
	}{})
	stub := fake.ActionFunc3Stub
	fakeReturns := fake.actionFunc3Returns
	fake.recordInvocation("ActionFunc3", []interface{}{})
	fake.actionFunc3Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCallers) ActionFunc3CallCount() int {
	fake.actionFunc3Mutex.RLock()
	defer fake.actionFunc3Mutex.RUnlock()
	return len(fake.actionFunc3ArgsForCall)
}

func (fake *FakeCallers) ActionFunc3Calls(stub func() error) {
	fake.actionFunc3Mutex.Lock()
	defer fake.actionFunc3Mutex.Unlock()
	fake.ActionFunc3Stub = stub
}

func (fake *FakeCallers) ActionFunc3Returns(result1 error) {
	fake.actionFunc3Mutex.Lock()
	defer fake.actionFunc3Mutex.Unlock()
	fake.ActionFunc3Stub = nil
	fake.actionFunc3Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCallers) ActionFunc3ReturnsOnCall(i int, result1 error) {
	fake.actionFunc3Mutex.Lock()
	defer fake.actionFunc3Mutex.Unlock()
	fake.ActionFunc3Stub = nil
	if fake.actionFunc3ReturnsOnCall == nil {
		fake.actionFunc3ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.actionFunc3ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCallers) RollbackActionFunc1() error {
	fake.rollbackActionFunc1Mutex.Lock()
	ret, specificReturn := fake.rollbackActionFunc1ReturnsOnCall[len(fake.rollbackActionFunc1ArgsForCall)]
	fake.rollbackActionFunc1ArgsForCall = append(fake.rollbackActionFunc1ArgsForCall, struct {
	}{})
	stub := fake.RollbackActionFunc1Stub
	fakeReturns := fake.rollbackActionFunc1Returns
	fake.recordInvocation("RollbackActionFunc1", []interface{}{})
	fake.rollbackActionFunc1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCallers) RollbackActionFunc1CallCount() int {
	fake.rollbackActionFunc1Mutex.RLock()
	defer fake.rollbackActionFunc1Mutex.RUnlock()
	return len(fake.rollbackActionFunc1ArgsForCall)
}

func (fake *FakeCallers) RollbackActionFunc1Calls(stub func() error) {
	fake.rollbackActionFunc1Mutex.Lock()
	defer fake.rollbackActionFunc1Mutex.Unlock()
	fake.RollbackActionFunc1Stub = stub
}

func (fake *FakeCallers) RollbackActionFunc1Returns(result1 error) {
	fake.rollbackActionFunc1Mutex.Lock()
	defer fake.rollbackActionFunc1Mutex.Unlock()
	fake.RollbackActionFunc1Stub = nil
	fake.rollbackActionFunc1Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCallers) RollbackActionFunc1ReturnsOnCall(i int, result1 error) {
	fake.rollbackActionFunc1Mutex.Lock()
	defer fake.rollbackActionFunc1Mutex.Unlock()
	fake.RollbackActionFunc1Stub = nil
	if fake.rollbackActionFunc1ReturnsOnCall == nil {
		fake.rollbackActionFunc1ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rollbackActionFunc1ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCallers) RollbackActionFunc2() error {
	fake.rollbackActionFunc2Mutex.Lock()
	ret, specificReturn := fake.rollbackActionFunc2ReturnsOnCall[len(fake.rollbackActionFunc2ArgsForCall)]
	fake.rollbackActionFunc2ArgsForCall = append(fake.rollbackActionFunc2ArgsForCall, struct {
	}{})
	stub := fake.RollbackActionFunc2Stub
	fakeReturns := fake.rollbackActionFunc2Returns
	fake.recordInvocation("RollbackActionFunc2", []interface{}{})
	fake.rollbackActionFunc2Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCallers) RollbackActionFunc2CallCount() int {
	fake.rollbackActionFunc2Mutex.RLock()
	defer fake.rollbackActionFunc2Mutex.RUnlock()
	return len(fake.rollbackActionFunc2ArgsForCall)
}

func (fake *FakeCallers) RollbackActionFunc2Calls(stub func() error) {
	fake.rollbackActionFunc2Mutex.Lock()
	defer fake.rollbackActionFunc2Mutex.Unlock()
	fake.RollbackActionFunc2Stub = stub
}

func (fake *FakeCallers) RollbackActionFunc2Returns(result1 error) {
	fake.rollbackActionFunc2Mutex.Lock()
	defer fake.rollbackActionFunc2Mutex.Unlock()
	fake.RollbackActionFunc2Stub = nil
	fake.rollbackActionFunc2Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCallers) RollbackActionFunc2ReturnsOnCall(i int, result1 error) {
	fake.rollbackActionFunc2Mutex.Lock()
	defer fake.rollbackActionFunc2Mutex.Unlock()
	fake.RollbackActionFunc2Stub = nil
	if fake.rollbackActionFunc2ReturnsOnCall == nil {
		fake.rollbackActionFunc2ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rollbackActionFunc2ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCallers) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCallers) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ list_operator_mocks.Callers = new(FakeCallers)
